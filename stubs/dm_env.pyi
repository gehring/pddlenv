import abc
import enum
from typing import Any, NamedTuple, Optional, Protocol, Tuple, Type

import numpy as np


class StepType(enum.IntEnum):
    FIRST: int
    MID: int
    LAST: int

    def first(self) -> bool: ...
    def mid(self) -> bool: ...
    def last(self) -> bool: ...


class TimeStep(NamedTuple):
    step_type: StepType
    reward: Any
    discount: Any
    observation: Any

    def first(self) -> bool: ...
    def mid(self) -> bool: ...
    def last(self) -> bool: ...


class Array(object):

  @property
  def shape(self) -> Any: ...

  @property
  def dtype(self) -> Any: ...

  @property
  def name(self) -> Optional[str]: ...

  def __repr__(self) -> str: ...
  def __eq__(self, other) -> bool: ...
  def __ne__(self, other) -> bool: ...
  def validate(self, value) -> np.ndarray: ...
  def generate_value(self) -> np.ndarray: ...
  def replace(self, **kwargs) -> "Array": ...
  def __reduce__(self) -> Tuple[Type["Array"], Tuple[Any, Any, Optional[str]]]:...



class Environment(Protocol):
  def reward_spec(self) -> Array: ...
  def discount_spec(self) -> Array: ...
  def close(self): ...
  def __enter__(self) -> "Environment": ...
  def __exit__(self, exc_type, exc_value, traceback): ...

  @abc.abstractmethod
  def reset(self) -> TimeStep: ...

  @abc.abstractmethod
  def step(self, action) -> TimeStep: ...

  @abc.abstractmethod
  def observation_spec(self) -> Array: ...

  @abc.abstractmethod
  def action_spec(self) -> Array: ...


def restart(observation) -> TimeStep: ...
def transition(reward, observation, discount=1.0) -> TimeStep: ...
def termination(reward, observation) -> TimeStep: ...
def truncation(reward, observation, discount=1.0) -> TimeStep: ...
